/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.

import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate, CacheFirst, NetworkFirst, NetworkOnly } from 'workbox-strategies';
import { BackgroundSyncPlugin } from 'workbox-background-sync';

// Versione del service worker (sincronizzata con version.json)
let SW_VERSION = 'unknown';

// Gestisce gli aggiornamenti del service worker
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    console.log('[Service Worker] Ricevuto messaggio SKIP_WAITING, attivazione immediata');
    self.skipWaiting();
  }
});

async function fetchAppVersion() {
  try {
    const response = await fetch('/version.json?sw=' + Date.now(), { cache: 'no-store' });
    if (response.ok) {
      const data = await response.json();
      SW_VERSION = data.version || 'unknown';
    }
  } catch (e) {
    console.warn('[Service Worker] Impossibile recuperare version.json:', e);
  }
}

console.log(`[Service Worker versione dinamica] Caricamento...`);

clientsClaim();

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST);

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');
registerRoute(
  // Return false to exempt requests from being fulfilled by index.html.
  ({ request, url }) => {
    // If this isn't a navigation, skip.
    if (request.mode !== 'navigate') {
      return false;
    } // If this is a URL that starts with /_, skip.

    if (url.pathname.startsWith('/_')) {
      return false;
    } // If this looks like a URL for a resource, because it contains // a file extension, skip.

    if (url.pathname.match(fileExtensionRegexp)) {
      return false;
    } // Return true to signal that we want to use the handler.

    return true;
  },
  createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html')
);

// Cache images
registerRoute(
  // Add in any other file extensions or routing criteria as needed.
  ({ url }) => url.origin === self.location.origin && 
    (url.pathname.endsWith('.png') || url.pathname.endsWith('.jpg') || url.pathname.endsWith('.jpeg') || url.pathname.endsWith('.svg')),
  new CacheFirst({
    cacheName: 'images',
    plugins: [
      // Ensure that once this runtime cache reaches a maximum size the
      // least-recently used images are removed.
      new ExpirationPlugin({ 
        maxEntries: 50,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 Days
      }),
    ],
  })
);

// Cache CSS and JavaScript files
registerRoute(
  ({ url }) => url.origin === self.location.origin && 
    (url.pathname.endsWith('.css') || url.pathname.endsWith('.js')),
  new StaleWhileRevalidate({
    cacheName: 'static-resources',
  })
);

// Cache API endpoints - usa NetworkFirst per preferire dati aggiornati quando possibile
registerRoute(
  ({ url }) => url.origin === self.location.origin && 
    (url.pathname.startsWith('/timbrature') || 
     url.pathname.startsWith('/requests') || 
     url.pathname.startsWith('/user')),
  new NetworkFirst({
    cacheName: 'api-responses',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 7 * 24 * 60 * 60, // 7 Days
      }),
    ],
  })
);

// Background sync per timbrature
const timbratureBackgroundSyncPlugin = new BackgroundSyncPlugin('timbrature-queue', {
  maxRetentionTime: 24 * 60, // Retry for max 24 Hours (expressed in minutes)
  onSync: async ({queue}) => {
    // Questa funzione viene eseguita quando la sincronizzazione parte
    let entry;
    while ((entry = await queue.shiftRequest())) {
      try {
        // Ripeti la richiesta e aspetta la risposta
        await fetch(entry.request);
        console.log('Timbratura sincronizzata con successo');
        
        // Qui puoi inviare una notifica all'utente
        self.registration.showNotification('TimbrApp', {
          body: 'La tua timbratura è stata sincronizzata con successo',
          icon: '/icon-192x192.png'
        });
      } catch (error) {
        console.error('Error replaying timbratura:', error);
        // Se fallisce, rimetti in coda
        await queue.unshiftRequest(entry);
        // E lancia un'eccezione
        throw error;
      }
    }
  },
});

// Background sync per richieste
const requestsBackgroundSyncPlugin = new BackgroundSyncPlugin('requests-queue', {
  maxRetentionTime: 24 * 60, // Retry for max 24 Hours (expressed in minutes)
});

// Gestisci i POST di timbrature offline
registerRoute(
  ({ url }) => url.pathname.startsWith('/timbrature') && url.origin === self.location.origin,
  new NetworkOnly({
    plugins: [timbratureBackgroundSyncPlugin],
  }),
  'POST'
);

// Gestisci i POST di richieste ferie/permessi offline
registerRoute(
  ({ url }) => url.pathname.startsWith('/requests') && url.origin === self.location.origin,
  new NetworkOnly({
    plugins: [requestsBackgroundSyncPlugin],
  }),
  'POST'
);

// Skip per richieste a FCM
registerRoute(
  ({ url }) => url.href.includes('fcm.googleapis.com'),
  new NetworkOnly()
);

// Gestione eventi di sincronizzazione (backward compatibility)
self.addEventListener('sync', event => {
  if (event.tag === 'sync-timbrature') {
    console.log('[Service Worker] Sincronizzazione timbrature');
    event.waitUntil(syncTimbrature());
  }
  if (event.tag === 'sync-requests') {
    console.log('[Service Worker] Sincronizzazione richieste');
    event.waitUntil(syncRequests());
  }
});

// Sincronizzazione manuale (se non supportata via BackgroundSyncPlugin)
async function syncTimbrature() {
  try {
    // Apri database
    const db = await openDB();
    const tx = db.transaction('offlineTimbrature', 'readonly');
    const store = tx.objectStore('offlineTimbrature');
    const timbratureToSync = await store.getAll();
    
    console.log(`[Service Worker] ${timbratureToSync.length} timbrature da sincronizzare`);
    
    if (timbratureToSync.length === 0) return;
    
    // Per ogni timbratura offline
    for (const item of timbratureToSync) {
      try {
        const response = await fetch('/timbrature', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${item.token}`
          },
          body: JSON.stringify(item.timbratura)
        });
        
        if (response.ok) {
          // Rimuovi dalla coda offline
          await db.transaction('offlineTimbrature', 'readwrite')
            .objectStore('offlineTimbrature')
            .delete(item.id);
          
          console.log(`[Service Worker] Timbratura ${item.id} sincronizzata`);
        } else {
          console.error(`[Service Worker] Errore sincronizzazione timbratura ${item.id}:`, await response.text());
        }
      } catch (error) {
        console.error(`[Service Worker] Errore sincronizzazione timbratura ${item.id}:`, error);
      }
    }
    
    // Notifica utente
    self.registration.showNotification('TimbrApp', {
      body: 'Timbrature sincronizzate con successo',
      icon: '/icon-192x192.png'
    });
  } catch (error) {
    console.error('[Service Worker] Errore sincronizzazione timbrature:', error);
  }
}

// Sincronizzazione richieste ferie/permessi
async function syncRequests() {
  // Implementazione simile a syncTimbrature
  console.log('[Service Worker] Sincronizzazione richieste non implementata');
}

// Helper per aprire IndexedDB
function openDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('TimbrAppOfflineDB', 1);
    
    request.onsuccess = event => resolve(event.target.result);
    request.onerror = event => reject(event.target.error);
  });
}

// Installazione del Service Worker
self.addEventListener('install', (event) => {
  event.waitUntil(fetchAppVersion());
  console.log(`[Service Worker ${SW_VERSION}] Installing...`);
  
  // Skip waiting per attivare immediatamente questo SW
  self.skipWaiting();
});

// Attivazione del Service Worker
self.addEventListener('activate', (event) => {
  event.waitUntil(fetchAppVersion());
  console.log(`[Service Worker ${SW_VERSION}] Activating...`);
  
  // Claim clients per controllare subito tutte le schede
  event.waitUntil(self.clients.claim());
  
  // Eliminare cache vecchie
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.filter(cacheName => {
          return cacheName.startsWith('atwork-cache-') && cacheName !== `atwork-cache-${SW_VERSION}`;
        }).map(cacheName => {
          console.log(`[Service Worker] Deleting old cache: ${cacheName}`);
          return caches.delete(cacheName);
        })
      );
    })
  );
});

// Gestione delle notifiche push con supporto iOS migliorato
self.addEventListener('push', (event) => {
  console.log('[Service Worker] Push ricevuto:', event);
  
  let notificationData = {};
  
  try {
    if (event.data) {
      notificationData = event.data.json();
      console.log('[Service Worker] Payload notifica:', notificationData);
    } else {
      console.warn('[Service Worker] Ricevuto push senza dati');
      notificationData = {
        title: 'Nuova notifica',
        body: 'Hai ricevuto una nuova notifica',
        icon: '/icon-192x192.png'
      };
    }
  } catch (e) {
    console.error('[Service Worker] Errore parsing payload:', e);
    notificationData = {
      title: 'Nuova notifica',
      body: 'Hai ricevuto una nuova notifica',
      icon: '/icon-192x192.png'
    };
  }

  const options = {
    body: notificationData.body || 'Hai ricevuto una nuova notifica',
    icon: notificationData.icon || '/icon-192x192.png',
    badge: '/icon-192x192.png',
    data: notificationData.data || {},
    tag: notificationData.tag || 'default',
    renotify: true,
    requireInteraction: true,
    silent: false,
    timestamp: Date.now(),
    actions: [
      {
        action: 'open',
        title: 'Apri'
      }
    ]
  };

  event.waitUntil(
    self.registration.showNotification(notificationData.title || 'TimbrApp', options)
      .then(() => {
        console.log('[Service Worker] Notifica mostrata con successo');
      })
      .catch(err => {
        console.error('[Service Worker] Errore mostrando notifica:', err);
      })
  );
});

// Gestione click su notifiche migliorata per iOS
self.addEventListener('notificationclick', (event) => {
  console.log('[Service Worker] Click su notifica:', event.notification);
  
  event.notification.close();
  
  let url = '/';
  if (event.notification.data?.url) {
    url = event.notification.data.url;
  }

  event.waitUntil(
    clients.matchAll({ type: 'window', includeUncontrolled: true })
      .then(windowClients => {
        // Cerca una finestra già aperta
        const matchingClient = windowClients.find(client => 
          client.url.indexOf(url) > -1
        );

        if (matchingClient) {
          return matchingClient.focus();
        }

        // Se non trova finestre aperte, ne apre una nuova
        return clients.openWindow(url);
      })
      .catch(err => {
        console.error('[Service Worker] Errore gestione click:', err);
      })
  );
});

// Gestione chiusura notifica (senza click)
self.addEventListener('notificationclose', (event) => {
  console.log('[Service Worker] Notifica chiusa senza interazione:', event.notification);
});

// Messaggio dal client
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
    // Notifica i client che il SW è attivo
    self.clients.matchAll({ type: 'window' }).then(clients => {
      clients.forEach(client => client.postMessage({ type: 'RELOAD_PAGE' }));
    });
  }
});

console.log(`[Service Worker ${SW_VERSION}] Loaded successfully`);